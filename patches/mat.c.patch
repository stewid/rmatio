*** mat.c.orig	2017-07-27 19:52:39.556154473 +0200
--- mat.c	2017-07-27 19:53:21.767887190 +0200
***************
*** 30,54 ****
   * POSSIBILITY OF SUCH DAMAGE.
   */
  
! /* FIXME: Implement Unicode support */
! #include <stdlib.h>
! #include <string.h>
! #include <stdio.h>
! #include <math.h>
! #include <time.h>
! #if HAVE_INTTYPES_H
! #   define __STDC_FORMAT_MACROS
! #   include <inttypes.h>
! #endif
! #if defined(_WIN64) || defined(_WIN32)
! #   include <io.h>
! #   define mktemp _mktemp
! #endif
! #if defined(_MSC_VER) || defined(__MINGW32__)
! #   define SIZE_T_FMTSTR "Iu"
! #else
! #   define SIZE_T_FMTSTR "zu"
! #endif
  #include "matio_private.h"
  #include "mat5.h"
  #include "mat4.h"
--- 30,48 ----
   * POSSIBILITY OF SUCH DAMAGE.
   */
  
! /*
!  * Changes in the R package rmatio:
!  *
!  * - The io routines have been adopted to use R printing and error routines.
!  *   See the R manual Writing R Extensions
!  *
!  */
! 
! /* Stefan Widgren 2014-01-05: Include only header files neccessary to
!  * build the rmatio package */
! 
! #include <Rdefines.h>
! #include "config.h"
  #include "matio_private.h"
  #include "mat5.h"
  #include "mat4.h"
***************
*** 72,133 ****
      return;
  }
  
! static void
! Mat_PrintNumber(enum matio_types type, void *data)
  {
!     switch ( type ) {
          case MAT_T_DOUBLE:
!             printf("%g",*(double*)data);
!             break;
          case MAT_T_SINGLE:
!             printf("%g",*(float*)data);
!             break;
  #ifdef HAVE_MAT_INT64_T
          case MAT_T_INT64:
! #if HAVE_INTTYPES_H
!             printf("%" PRIi64,*(mat_int64_t*)data);
! #elif defined(_MSC_VER) && _MSC_VER >= 1200
!             printf("%I64i",*(mat_int64_t*)data);
! #elif defined(HAVE_LONG_LONG_INT)
!             printf("%lld",(long long)(*(mat_int64_t*)data));
! #else
!             printf("%ld",(long)(*(mat_int64_t*)data));
! #endif
!             break;
  #endif
  #ifdef HAVE_MAT_UINT64_T
          case MAT_T_UINT64:
! #if HAVE_INTTYPES_H
!             printf("%" PRIu64,*(mat_uint64_t*)data);
! #elif defined(_MSC_VER) && _MSC_VER >= 1200
!             printf("%I64u",*(mat_uint64_t*)data);
! #elif defined(HAVE_UNSIGNED_LONG_LONG_INT)
!             printf("%llu",(unsigned long long)(*(mat_uint64_t*)data));
! #else
!             printf("%lu",(unsigned long)(*(mat_uint64_t*)data));
! #endif
!             break;
  #endif
          case MAT_T_INT32:
!             printf("%d",*(mat_int32_t*)data);
!             break;
          case MAT_T_UINT32:
!             printf("%u",*(mat_uint32_t*)data);
!             break;
          case MAT_T_INT16:
!             printf("%hd",*(mat_int16_t*)data);
!             break;
          case MAT_T_UINT16:
!             printf("%hu",*(mat_uint16_t*)data);
!             break;
          case MAT_T_INT8:
!             printf("%hhd",*(mat_int8_t*)data);
!             break;
          case MAT_T_UINT8:
!             printf("%hhu",*(mat_uint8_t*)data);
!             break;
          default:
!             break;
      }
  }
  
--- 66,115 ----
      return;
  }
  
! /* Stefan Widgren 2014-01-04: Mat_SizeOf moved from io.c */
! 
! /** @brief Calculate the size of MAT data types
!  *
!  * @ingroup mat_util
!  * @param data_type Data type enumeration
!  * @return size of the data type in bytes
!  */
! size_t
! Mat_SizeOf(enum matio_types data_type)
  {
!     switch (data_type) {
          case MAT_T_DOUBLE:
!             return sizeof(double);
          case MAT_T_SINGLE:
!             return sizeof(float);
  #ifdef HAVE_MAT_INT64_T
          case MAT_T_INT64:
!             return sizeof(mat_int64_t);
  #endif
  #ifdef HAVE_MAT_UINT64_T
          case MAT_T_UINT64:
!             return sizeof(mat_uint64_t);
  #endif
          case MAT_T_INT32:
!             return sizeof(mat_int32_t);
          case MAT_T_UINT32:
!             return sizeof(mat_uint32_t);
          case MAT_T_INT16:
!             return sizeof(mat_int16_t);
          case MAT_T_UINT16:
!             return sizeof(mat_uint16_t);
          case MAT_T_INT8:
!             return sizeof(mat_int8_t);
          case MAT_T_UINT8:
!             return sizeof(mat_uint8_t);
!         case MAT_T_UTF8:
!             return 1;
!         case MAT_T_UTF16:
!             return 2;
!         case MAT_T_UTF32:
!             return 4;
          default:
!             return 0;
      }
  }
  
***************
*** 820,917 ****
      return 0;
  }
  
- /** @brief Deletes a variable from a file
-  *
-  * @ingroup MAT
-  * @param mat Pointer to the mat_t file structure
-  * @param name Name of the variable to delete
-  * @returns 0 on success
-  */
- int
- Mat_VarDelete(mat_t *mat, const char *name)
- {
-     int   err = 1;
-     char *tmp_name;
-     char temp[7] = "XXXXXX";
- 
-     if ( NULL == mat || NULL == name )
-         return err;
- 
-     if ( (tmp_name = mktemp(temp)) != NULL ) {
-         enum mat_ft mat_file_ver = MAT_FT_DEFAULT;
-         mat_t *tmp;
- 
-         switch ( mat->version ) {
-             case 0x0200:
-                 mat_file_ver = MAT_FT_MAT73;
-                 break;
-             case 0x0100:
-                 mat_file_ver = MAT_FT_MAT5;
-                 break;
-             case 0x0010:
-                 mat_file_ver = MAT_FT_MAT4;
-                 break;
-         }
- 
-         tmp = Mat_CreateVer(tmp_name,mat->header,mat_file_ver);
-         if ( tmp != NULL ) {
-             matvar_t *matvar;
-             while ( NULL != (matvar = Mat_VarReadNext(mat)) ) {
-                 if ( strcmp(matvar->name,name) )
-                     Mat_VarWrite(tmp,matvar,matvar->compression);
-                 else
-                     err = 0;
-                 Mat_VarFree(matvar);
-             }
-             Mat_Close(tmp);
- 
-             if ( err == 0 ) {
-                 char *new_name = strdup_printf("%s",mat->filename);
- #if defined(MAT73) && MAT73
-                 if ( mat_file_ver == MAT_FT_MAT73 ) {
-                     if ( mat->refs_id > -1 )
-                         H5Gclose(mat->refs_id);
-                     H5Fclose(*(hid_t*)mat->fp);
-                     free(mat->fp);
-                     mat->fp = NULL;
-                 }
- #endif
-                 if ( mat->fp ) {
-                     fclose((FILE*)mat->fp);
-                     mat->fp = NULL;
-                 }
- 
-                 if ( (err = mat_copy(tmp_name,new_name)) == -1 ) {
-                     Mat_Critical("Cannot copy file from \"%s\" to \"%s\".",
-                         tmp_name, new_name);
-                 } else if ( (err = remove(tmp_name)) == -1 ) {
-                     Mat_Critical("Cannot remove file \"%s\".",tmp_name);
-                 } else {
-                     tmp = Mat_Open(new_name,mat->mode);
-                     if ( NULL != tmp ) {
-                         if ( mat->header )
-                             free(mat->header);
-                         if ( mat->subsys_offset )
-                             free(mat->subsys_offset);
-                         if ( mat->filename )
-                             free(mat->filename);
-                         memcpy(mat,tmp,sizeof(mat_t));
-                         free(tmp);
-                     } else {
-                         Mat_Critical("Cannot open file \"%s\".",new_name);
-                     }
-                 }
-                 free(new_name);
-             } else if ( (err = remove(tmp_name)) == -1 ) {
-                 Mat_Critical("Cannot remove file \"%s\".",tmp_name);
-             }
-         }
-     } else {
-         Mat_Critical("Cannot create a unique file name.");
-     }
-     return err;
- }
- 
  /** @brief Duplicates a matvar_t structure
   *
   * Provides a clean function for duplicating a matvar_t structure.
--- 802,807 ----
***************
*** 1503,1715 ****
      return bytes;
  }
  
- /** @brief Prints the variable information
-  *
-  * Prints to stdout the values of the @ref matvar_t structure
-  * @ingroup MAT
-  * @param matvar Pointer to the matvar_t structure
-  * @param printdata set to 1 if the Variables data should be printed, else 0
-  */
- void
- Mat_VarPrint( matvar_t *matvar, int printdata )
- {
-     size_t nmemb;
-     int i, j;
-     const char *class_type_desc[16] = {"Undefined","Cell Array","Structure",
-        "Object","Character Array","Sparse Array","Double Precision Array",
-        "Single Precision Array", "8-bit, signed integer array",
-        "8-bit, unsigned integer array","16-bit, signed integer array",
-        "16-bit, unsigned integer array","32-bit, signed integer array",
-        "32-bit, unsigned integer array","64-bit, signed integer array",
-        "64-bit, unsigned integer array"};
-     const char *data_type_desc[23] = {"Unknown","8-bit, signed integer",
-        "8-bit, unsigned integer","16-bit, signed integer",
-        "16-bit, unsigned integer","32-bit, signed integer",
-        "32-bit, unsigned integer","IEEE 754 single-precision","RESERVED",
-        "IEEE 754 double-precision","RESERVED","RESERVED",
-        "64-bit, signed integer","64-bit, unsigned integer", "Matlab Array",
-        "Compressed Data","Unicode UTF-8 Encoded Character Data",
-        "Unicode UTF-16 Encoded Character Data",
-        "Unicode UTF-32 Encoded Character Data","","String","Cell Array",
-        "Structure"};
- 
-     if ( matvar == NULL )
-         return;
-     if ( matvar->name )
-         printf("      Name: %s\n", matvar->name);
-     printf("      Rank: %d\n", matvar->rank);
-     if ( matvar->rank == 0 )
-         return;
-     printf("Dimensions: %" SIZE_T_FMTSTR,matvar->dims[0]);
-     nmemb = matvar->dims[0];
-     for ( i = 1; i < matvar->rank; i++ ) {
-         printf(" x %" SIZE_T_FMTSTR,matvar->dims[i]);
-         nmemb *= matvar->dims[i];
-     }
-     printf("\n");
-     printf("Class Type: %s",class_type_desc[matvar->class_type]);
-     if ( matvar->isComplex )
-         printf(" (complex)");
-     else if ( matvar->isLogical )
-         printf(" (logical)");
-     printf("\n");
-     if ( matvar->data_type )
-         printf(" Data Type: %s\n", data_type_desc[matvar->data_type]);
- 
-     if ( MAT_C_STRUCT == matvar->class_type ) {
-         matvar_t **fields = (matvar_t **)matvar->data;
-         int nfields = matvar->internal->num_fields;
-         if ( nmemb*nfields > 0 ) {
-             printf("Fields[%" SIZE_T_FMTSTR "] {\n", nfields*nmemb);
-             for ( i = 0; i < nfields*nmemb; i++ ) {
-                 if ( NULL == fields[i] ) {
-                     printf("      Name: %s\n      Rank: %d\n",
-                            matvar->internal->fieldnames[i%nfields],0);
-                 } else {
-                     Mat_VarPrint(fields[i],printdata);
-                 }
-             }
-             printf("}\n");
-         } else {
-             printf("Fields[%d] {\n", nfields);
-             for ( i = 0; i < nfields; i++ )
-                 printf("      Name: %s\n      Rank: %d\n",
-                        matvar->internal->fieldnames[i],0);
-             printf("}\n");
-         }
-         return;
-     } else if ( matvar->data == NULL || matvar->data_size < 1 ) {
-         if ( printdata )
-             printf("{\n}\n");
-         return;
-     } else if ( MAT_C_CELL == matvar->class_type ) {
-         matvar_t **cells = (matvar_t **)matvar->data;
-         int ncells = matvar->nbytes / matvar->data_size;
-         printf("{\n");
-         for ( i = 0; i < ncells; i++ )
-             Mat_VarPrint(cells[i],printdata);
-         printf("}\n");
-         return;
-     } else if ( !printdata ) {
-         return;
-     }
- 
-     printf("{\n");
- 
-     if ( matvar->rank > 2 ) {
-         printf("I can't print more than 2 dimensions\n");
-     } else if ( matvar->rank == 1 && matvar->dims[0] > 15 ) {
-         printf("I won't print more than 15 elements in a vector\n");
-     } else if ( matvar->rank==2 ) {
-         switch( matvar->class_type ) {
-             case MAT_C_DOUBLE:
-             case MAT_C_SINGLE:
- #ifdef HAVE_MAT_INT64_T
-             case MAT_C_INT64:
- #endif
- #ifdef HAVE_MAT_UINT64_T
-             case MAT_C_UINT64:
- #endif
-             case MAT_C_INT32:
-             case MAT_C_UINT32:
-             case MAT_C_INT16:
-             case MAT_C_UINT16:
-             case MAT_C_INT8:
-             case MAT_C_UINT8:
-             {
-                 size_t stride = Mat_SizeOf(matvar->data_type);
-                 if ( matvar->isComplex ) {
-                     mat_complex_split_t *complex_data = (mat_complex_split_t*)matvar->data;
-                     char *rp = (char*)complex_data->Re;
-                     char *ip = (char*)complex_data->Im;
-                     for ( i = 0; i < matvar->dims[0] && i < 15; i++ ) {
-                         for ( j = 0; j < matvar->dims[1] && j < 15; j++ ) {
-                             size_t idx = matvar->dims[0]*j+i;
-                             Mat_PrintNumber(matvar->data_type,rp+idx*stride);
-                             printf(" + ");
-                             Mat_PrintNumber(matvar->data_type,ip+idx*stride);
-                             printf("i ");
-                         }
-                         if ( j < matvar->dims[1] )
-                             printf("...");
-                         printf("\n");
-                     }
-                     if ( i < matvar->dims[0] )
-                         printf(".\n.\n.\n");
-                } else {
-                    char *data = (char*)matvar->data;
-                    for ( i = 0; i < matvar->dims[0] && i < 15; i++ ) {
-                         for ( j = 0; j < matvar->dims[1] && j < 15; j++ ) {
-                             size_t idx = matvar->dims[0]*j+i;
-                             Mat_PrintNumber(matvar->data_type,
-                                             data+idx*stride);
-                             printf(" ");
-                         }
-                         if ( j < matvar->dims[1] )
-                             printf("...");
-                         printf("\n");
-                     }
-                     if ( i < matvar->dims[0] )
-                         printf(".\n.\n.\n");
-                 }
-                 break;
-             }
-             case MAT_C_CHAR:
-             {
-                 char *data = (char*)matvar->data;
-                 for ( i = 0; i < matvar->dims[0]; i++ ) {
-                     for ( j = 0; j < matvar->dims[1]; j++ )
-                         printf("%c",data[j*matvar->dims[0]+i]);
-                     printf("\n");
-                 }
-                 break;
-             }
-             case MAT_C_SPARSE:
-             {
-                 mat_sparse_t *sparse;
-                 size_t stride = Mat_SizeOf(matvar->data_type);
- #if !defined(EXTENDED_SPARSE)
-                 if ( MAT_T_DOUBLE != matvar->data_type )
-                     break;
- #endif
-                 sparse = (mat_sparse_t*)matvar->data;
-                 if ( matvar->isComplex ) {
-                     mat_complex_split_t *complex_data = (mat_complex_split_t*)sparse->data;
-                     char *re = (char*)complex_data->Re;
-                     char *im = (char*)complex_data->Im;
-                     for ( i = 0; i < sparse->njc-1; i++ ) {
-                         for ( j = sparse->jc[i];
-                               j < sparse->jc[i+1] && j < sparse->ndata; j++ ) {
-                             printf("    (%d,%d)  ",sparse->ir[j]+1,i+1);
-                             Mat_PrintNumber(matvar->data_type,re+j*stride);
-                             printf(" + ");
-                             Mat_PrintNumber(matvar->data_type,im+j*stride);
-                             printf("i\n");
-                         }
-                     }
-                 } else {
-                     char *data = (char*)sparse->data;
-                     for ( i = 0; i < sparse->njc-1; i++ ) {
-                         for ( j = sparse->jc[i];
-                               j < sparse->jc[i+1] && j < sparse->ndata; j++ ) {
-                             printf("    (%d,%d)  ",sparse->ir[j]+1,i+1);
-                             Mat_PrintNumber(matvar->data_type,data+j*stride);
-                             printf("\n");
-                         }
-                     }
-                 }
-                 break;
-             } /* case MAT_C_SPARSE: */
-             default:
-                 break;
-         } /* switch( matvar->class_type ) */
-     }
- 
-     printf("}\n");
- 
-     return;
- }
- 
  /** @brief Reads MAT variable data from a file
   *
   * Reads data from a MAT variable.  The variable must have been read by
--- 1393,1398 ----
